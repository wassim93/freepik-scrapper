import { GoogleGenAI, Modality } from '@google/genai'
import { ENV } from '../config/env.config'
import { fileURLToPath } from 'url'
import fs from 'fs'
import path from 'path'
import { AssetMetaData } from '../types'

const modulePath = fileURLToPath(import.meta.url)
const __dirname = path.dirname(modulePath)
const OUTPUT_DIR = path.resolve(__dirname, '../output/assets')

const allStyles = [
  'vaporwave style',
  'cyberpunk aesthetic',
  'surrealism',
  'retro-futurism',
  'hyperrealism',
  'dreamcore',
  'anime illustration',
  'steampunk theme',
  'Ukiyo-e',
  'digital painting',
  'concept art',
  'fantasy art',
  'minimalist design',
  'watercolor sketch',
  'baroque art', // Added new style
  'geometric abstraction', // Added new style
  'impressionism', // Added new style
  'neon noir', // Added new style
  'flat design', // Added new style
]

const allLighting = [
  'golden hour lighting',
  'soft ambient glow',
  'dramatic shadows',
  'neon backlight',
  'natural daylight',
  'overcast mood',
  'spotlight focus',
  'sunset tones',
  'moonlit ambiance', // Added new lighting
  'soft glow from within', // Added new lighting
  'hazy and ethereal', // Added new lighting
  'high contrast with sharp shadows', // Added new lighting
]

const allPerspectives = [
  'top-down view',
  'wide angle shot',
  'macro close-up',
  'cinematic composition',
  'isometric view',
  'dreamlike atmosphere',
  'vivid background details',
  'symmetrical framing', // Added new perspective
  'low-angle shot', // Added new perspective
  'bird’s-eye view', // Added new perspective
  'abstract distorted angle', // Added new perspective
  'fisheye perspective', // Added new perspective
  'horizon line focus', // Added new perspective
]

// Color palette options
const allColorPalettes = [
  'pastel tones',
  'neon red & teal',
  'sepia tones',
  'black & gold',
  'vibrant rainbow hues',
  'earthy neutrals',
  'icy blue and silver',
  'muted pinks & blues',
  'soft beige and brown',
  'bold contrasting hues',
  'warm sunset colors',
  'deep ocean blues & greens',
  'electric purple and lime',
  'golden amber & ruby red',
  'monochrome grayscale with accents',
]

const minimalistStyles = [
  'flat illustration',
  'line art',
  '2D minimal vector',
  'duotone poster style',
  'contour drawing',
  'geometric abstraction',
  'monochrome line sketch',
  'minimalist design',
  'outline style',
  'simple icon style',
  'basic shape composition',
]

const minimalistLighting = ['soft ambient light', 'natural daylight', 'even flat lighting', 'monotone soft glow']

const minimalistColorPalettes = [
  'monochromatic palette',
  'duotone color scheme',
  'three-color palette',
  'black and white only',
  'soft pastel minimal palette',
  'earthy muted colors',
  'warm minimal tones',
  'cool toned minimal palette',
  'scandinavian style muted colors',
  'flat modern UI color set',
]

const minimalistPerspectives = [
  'flat side view',
  'top-down icon-style view',
  'front-facing composition',
  'symmetrical layout',
  'centered subject with negative space',
]
const moodAdjectives = ['serene', 'whimsical', 'playful', 'mysterious', 'calm', 'ethereal', 'uplifting', 'melancholic', 'vibrant', 'gentle']
export class GeminiService {
  geminiAi = new GoogleGenAI({ apiKey: ENV.AI_API_KEY })
  private lastPrompt: string | null = null

  getRandomElement = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)]

  /**
   * Generates an enhanced prompt from imageName using Gemini
   * @param imageName The name of the image to generate a prompt for
   * @param minimalMode If true, uses a more minimalist approach to prompt generation
   * @returns The an enhanced prompt generated by Gemini AI or null if generation failed
   */
  generateEnhancedPrompt = async (imageName: string, minimalMode = true): Promise<string | null> => {
    let newPrompt: string | null = null
    const maxAttempts = 5
    let attempt = 0

    while (attempt < maxAttempts) {
      const style = this.getRandomElement(minimalMode ? minimalistStyles : allStyles)
      const lightingValue = this.getRandomElement(minimalMode ? minimalistLighting : allLighting)
      const palette = this.getRandomElement(minimalMode ? minimalistColorPalettes : allColorPalettes)
      const perspective = this.getRandomElement(minimalMode ? minimalistPerspectives : allPerspectives)
      const mood = this.getRandomElement(moodAdjectives)

      const applyFlatVectorFlavor = minimalMode && Math.random() < 0.4

      let extraNotes = `- The overall mood should be ${mood}.`
      if (applyFlatVectorFlavor) {
        extraNotes += `
      - The illustration should follow a flat vector aesthetic
      - Use clean 2D shapes with subtle pastel or limited color palettes
      - Favor friendly and approachable forms with minimal detail
      - Inspired by modern onboarding illustrations and minimalist UI graphics`
      }

      // For non-minimal mode, explicitly avoid "highly detailed" or complex details to reduce errors
      const detailInstruction = minimalMode
        ? `- Emphasizes simplicity, clean lines, and minimalism`
        : `- Avoid highly detailed or overly complex descriptions to prevent image generation errors`

      const composedPrompt = `You are a professional AI image prompt engineer.
      Given the following image idea: "${imageName}", write a UNIQUE and creative image generation prompt that:

      ${detailInstruction}
      - Uses style: ${style}
      - Specifies lighting: ${lightingValue}
      - Uses a color palette: ${palette}
      - Mentions composition: ${perspective}
      - Encourages negative space and avoids background clutter
      - Avoids words like 'realistic', 'detailed', or 'textured'
      - Uses simple adjectives like "clean", "basic", "minimal"
      - Must not contain any text elements, titles, letters, numbers, logos, branding, watermarks, or written symbols of any kind
      - Must be high-resolution (300 DPI)
      ${extraNotes}

      Only respond with the final prompt to use in an AI image generation model.`

      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: composedPrompt,
      })

      newPrompt = response?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || null

      if (newPrompt && newPrompt !== this.lastPrompt) {
        this.lastPrompt = newPrompt
        break
      }

      attempt++
    }

    return newPrompt
  }

  /**
   * Generates an image using Gemini and saves it to OUTPUT_DIR
   * @param prompt The text prompt to generate the image
   * @returns The full file path of the saved image, or null if generation failed
   */
  generateImage = async (prompt: string): Promise<string | null> => {
    try {
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_IMAGE_MODEL,
        contents: prompt,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      })

      const parts = response?.candidates?.[0]?.content?.parts
      if (!parts || parts.length === 0) {
        console.error('Error: No content parts received.')
        return null
      }

      for (const part of parts) {
        // Save image data if present
        if (part.inlineData?.data) {
          const imageData = part.inlineData.data
          // Ensure output directory exists
          if (!fs.existsSync(OUTPUT_DIR)) {
            fs.mkdirSync(OUTPUT_DIR, { recursive: true })
          }
          // Generate a unique filename
          const filename = `gemini-image-${Date.now()}.png`
          const filePath = path.join(OUTPUT_DIR, filename)
          // Write the image file
          const buffer = Buffer.from(imageData, 'base64')
          fs.writeFileSync(filePath, buffer)
          //console.log(`Image saved to ${filePath}`)
          return filePath
        }
        // Log any text part
        if (part.text) {
          console.log('Generated text:', part.text)
        }
      }

      console.error('Error: No valid image data found in parts.')
      return null
    } catch (error: any) {
      console.error('Error generating image:', error)
      return null
    }
  }

  /**
   * Generates SEO-friendly metadata (title, description, keywords) for Adobe Stock.
   * @param enhancedPrompt AI prompt describing the image
   * @returns An object with title, description, and keywords or null on failure
   */
  generateStockMetadata = async (enhancedPrompt: string): Promise<AssetMetaData | null> => {
    try {
      // Build instruction prompt
      const instruction = `You are an expert stock photo metadata generator.
      Based on the following detailed prompt, produce a JSON object with the following keys:

      1) title: a concise, SEO-friendly title (maximum 70 characters),
      2) description: a factual, objective 2–3 sentence description of the image content. Do NOT mention usage rights, licensing, commercial use, or watermarks (maximum 190 characters).
      3) keywords: an array of up to 50 relevant, comma-separated keywords suitable for stock search. Avoid terms related to licensing such as "no watermark", "free to use", "royalty free", "license", "300 DPI" or "commercial use".

      Prompt:
      "${enhancedPrompt}"`
      // Call Gemini
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: instruction,
      })

      const text = response?.candidates?.[0]?.content?.parts?.[0]?.text
      if (!text) return null

      // Extract JSON substring
      const start = text.indexOf('{')
      const end = text.lastIndexOf('}') + 1
      if (start === -1 || end === -1) return null
      const jsonStr = text.slice(start, end)

      const metadata = JSON.parse(jsonStr)
      const disallowedTerms = ['commercial use', 'no watermark', 'free to use', 'royalty free', 'license']
      const keywords: string[] = (metadata.keywords || []).filter((kw: string) => !disallowedTerms.some((term) => kw.toLowerCase().includes(term)))
      // Clean and smart-truncate description
      let description = (metadata.description || '').replace(new RegExp(disallowedTerms.join('|'), 'gi'), '').trim()

      if (description.length > 190) {
        const truncated = description.slice(0, 190)
        const lastSpace = truncated.lastIndexOf(' ')
        description = truncated.slice(0, lastSpace).trim()
      }

      return {
        title: metadata.title?.trim(),
        description,
        keywords,
      }
    } catch (error) {
      console.error('Error generating stock metadata:', error)
      return null
    }
  }
}
