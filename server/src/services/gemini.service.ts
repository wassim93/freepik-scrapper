import { GoogleGenAI, Modality } from '@google/genai'
import { ENV } from '../config/env.config'
import { fileURLToPath } from 'url'
import fs from 'fs'
import path from 'path'
import { AssetMetaData } from '../types'

const modulePath = fileURLToPath(import.meta.url)
const __dirname = path.dirname(modulePath)
const OUTPUT_DIR = path.resolve(__dirname, '../output/assets')

const styles = [
  'vaporwave style',
  'cyberpunk aesthetic',
  'surrealism',
  'retro-futurism',
  'hyperrealism',
  'dreamcore',
  'anime illustration',
  'steampunk theme',
  'Ukiyo-e',
  'digital painting',
  'concept art',
  'fantasy art',
  'minimalist design',
  'watercolor sketch',
  'baroque art', // Added new style
  'geometric abstraction', // Added new style
  'impressionism', // Added new style
  'neon noir', // Added new style
  'flat design', // Added new style
]

const lighting = [
  'golden hour lighting',
  'soft ambient glow',
  'dramatic shadows',
  'neon backlight',
  'natural daylight',
  'overcast mood',
  'spotlight focus',
  'sunset tones',
  'moonlit ambiance', // Added new lighting
  'soft glow from within', // Added new lighting
  'hazy and ethereal', // Added new lighting
  'high contrast with sharp shadows', // Added new lighting
]

const perspectives = [
  'top-down view',
  'wide angle shot',
  'macro close-up',
  'cinematic composition',
  'isometric view',
  'dreamlike atmosphere',
  'vivid background details',
  'symmetrical framing', // Added new perspective
  'low-angle shot', // Added new perspective
  'bird’s-eye view', // Added new perspective
  'abstract distorted angle', // Added new perspective
  'fisheye perspective', // Added new perspective
  'horizon line focus', // Added new perspective
]

// Color palette options
const colorPalettes = [
  'pastel tones',
  'neon red & teal',
  'sepia tones',
  'black & gold',
  'vibrant rainbow hues',
  'earthy neutrals',
  'icy blue and silver',
  'muted pinks & blues',
  'soft beige and brown',
  'bold contrasting hues',
  'warm sunset colors',
  'deep ocean blues & greens',
  'electric purple and lime',
  'golden amber & ruby red',
  'monochrome grayscale with accents',
]
export class GeminiService {
  geminiAi = new GoogleGenAI({ apiKey: ENV.AI_API_KEY })
  getRandomElement = (arr: string[]) => arr[Math.floor(Math.random() * arr.length)]

  /**
   * Generates an enhanced prompt from imageName using Gemini
   * @param imageName The name of the image to generate a prompt for
   * @returns The an enhanced prompt generated by Gemini AI or null if generation failed
   */
  generateEnhancedPrompt = async (imageName: string): Promise<string | null> => {
    try {
      const randomStyle = this.getRandomElement(styles)
      const randomLighting = this.getRandomElement(lighting)
      const randomPerspective = this.getRandomElement(perspectives)
      const randomPalette = this.getRandomElement(colorPalettes)
      const composedPrompt = `You are a professional AI image prompt engineer.
      Given the following image idea: "${imageName}", write a UNIQUE and imaginative prompt that:
      
      - Includes vivid, immersive visual storytelling with poetic nuance
      - Integrates original, unexpected abstract or symbolic details
      - Specifies style: ${randomStyle}
      - Mentions lighting: ${randomLighting}
      - Adds color palette ideas: ${randomPalette}
      - Suggests angle or composition: ${randomPerspective}
      - Specifies that the image should be created at 300 DPI for high-resolution output
      - Avoids repetition or generic phrases
      - Does NOT include watermarks, branding, text, or logos
      
      The result must be optimized to produce a stunning, professional, and visually captivating image suitable for a design marketplace.
      
      Respond with only the prompt to be used with an image generation model.`

      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: composedPrompt,
      })

      if (
        response &&
        response.candidates &&
        response.candidates[0] &&
        response.candidates[0].content &&
        response.candidates[0].content.parts &&
        response.candidates[0].content.parts[0].text
      ) {
        const prompt = response.candidates[0].content.parts[0].text
        console.log('Generated Enhanced Prompt (for flash):', prompt)
        return prompt
      } else {
        console.log('No valid prompt received.')
        return null
      }
    } catch (error) {
      console.error('Error generating prompt:', error)
      return null
    }
  }

  /**
   * Generates an image using Gemini and saves it to OUTPUT_DIR
   * @param prompt The text prompt to generate the image
   * @returns The full file path of the saved image, or null if generation failed
   */
  generateImage = async (prompt: string): Promise<string | null> => {
    try {
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_IMAGE_MODEL,
        contents: prompt,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      })

      const parts = response?.candidates?.[0]?.content?.parts
      if (!parts || parts.length === 0) {
        console.error('Error: No content parts received.')
        return null
      }

      for (const part of parts) {
        // Save image data if present
        if (part.inlineData?.data) {
          const imageData = part.inlineData.data
          // Ensure output directory exists
          if (!fs.existsSync(OUTPUT_DIR)) {
            fs.mkdirSync(OUTPUT_DIR, { recursive: true })
          }
          // Generate a unique filename
          const filename = `gemini-image-${Date.now()}.jpg`
          const filePath = path.join(OUTPUT_DIR, filename)
          // Write the image file
          const buffer = Buffer.from(imageData, 'base64')
          fs.writeFileSync(filePath, buffer)
          //console.log(`Image saved to ${filePath}`)
          return filePath
        }
        // Log any text part
        if (part.text) {
          console.log('Generated text:', part.text)
        }
      }

      console.error('Error: No valid image data found in parts.')
      return null
    } catch (error: any) {
      console.error('Error generating image:', error)
      return null
    }
  }

  /**
   * Generates SEO-friendly metadata (title, description, keywords) for Adobe Stock.
   * @param enhancedPrompt AI prompt describing the image
   * @returns An object with title, description, and keywords or null on failure
   */
  generateStockMetadata = async (enhancedPrompt: string): Promise<AssetMetaData | null> => {
    try {
      // Build instruction prompt
      const instruction = `You are an expert stock photo metadata generator.
      Based on the following detailed prompt, produce a JSON object with the following keys:

      1) title: a concise, SEO-friendly title (maximum 70 characters),
      2) description: a factual, objective 2–3 sentence description of the image content. Do NOT mention usage rights, licensing, commercial use, or watermarks (maximum 200 characters).
      3) keywords: an array of up to 50 relevant, comma-separated keywords suitable for stock search. Avoid terms related to licensing such as "no watermark", "free to use", or "commercial use".

      Prompt:
      "${enhancedPrompt}"`
      // Call Gemini
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: instruction,
      })

      const text = response?.candidates?.[0]?.content?.parts?.[0]?.text
      if (!text) return null

      // Extract JSON substring
      const start = text.indexOf('{')
      const end = text.lastIndexOf('}') + 1
      if (start === -1 || end === -1) return null
      const jsonStr = text.slice(start, end)

      const metadata = JSON.parse(jsonStr)
      const disallowedTerms = ['commercial use', 'no watermark', 'free to use', 'royalty free', 'license']
      const keywords: string[] = (metadata.keywords || []).filter((kw: string) => !disallowedTerms.some((term) => kw.toLowerCase().includes(term)))
      const description: string = metadata.description?.replace(new RegExp(disallowedTerms.join('|'), 'gi'), '').trim()

      return {
        title: metadata.title?.trim(),
        description,
        keywords,
      }
    } catch (error) {
      console.error('Error generating stock metadata:', error)
      return null
    }
  }
}
