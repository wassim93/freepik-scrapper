import { GoogleGenAI, Modality } from '@google/genai'
import { ENV } from '../config/env.config'
import { fileURLToPath } from 'url'
import fs from 'fs'
import path from 'path'
import { AssetMetaData } from '../types'

const modulePath = fileURLToPath(import.meta.url)
const __dirname = path.dirname(modulePath)
const OUTPUT_DIR = path.resolve(__dirname, '../output/assets')
export class GeminiService {
  geminiAi = new GoogleGenAI({ apiKey: ENV.AI_API_KEY })

  /**
   * Generates an enhanced prompt from imageName using Gemini
   * @param imageName The name of the image to generate a prompt for
   * @returns The an enhanced prompt generated by Gemini AI or null if generation failed
   */
  generateEnhancedPrompt = async (imageName: string): Promise<string | null> => {
    try {
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: `Create a detailed and enhanced AI prompt to generate a high-resolution (at least 300 DPI) image of "${imageName}". The image should be suitable for use as a digital product or digital asset (such as printable artwork, design elements, clipart, or commercial-use graphics). Focus on creating a clean, professional, and visually appealing result that is free of watermarks, logos, or branding. Include details about the subject, recommended style or aesthetic, relevant keywords, and visual composition tips to ensure the image is ready for digital distribution or sale.`,
      })

      if (
        response &&
        response.candidates &&
        response.candidates[0] &&
        response.candidates[0].content &&
        response.candidates[0].content.parts &&
        response.candidates[0].content.parts[0].text
      ) {
        const prompt = response.candidates[0].content.parts[0].text
        console.log('Generated Enhanced Prompt (for flash):', prompt)
        return prompt
      } else {
        console.log('No valid prompt received.')
        return null
      }
    } catch (error) {
      console.error('Error generating prompt:', error)
      return null
    }
  }

  /**
   * Generates an image using Gemini and saves it to OUTPUT_DIR
   * @param prompt The text prompt to generate the image
   * @returns The full file path of the saved image, or null if generation failed
   */
  generateImage = async (prompt: string): Promise<string | null> => {
    try {
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_IMAGE_MODEL,
        contents: prompt,
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        },
      })

      const parts = response?.candidates?.[0]?.content?.parts
      if (!parts || parts.length === 0) {
        console.error('Error: No content parts received.')
        return null
      }

      for (const part of parts) {
        // Save image data if present
        if (part.inlineData?.data) {
          const imageData = part.inlineData.data
          // Ensure output directory exists
          if (!fs.existsSync(OUTPUT_DIR)) {
            fs.mkdirSync(OUTPUT_DIR, { recursive: true })
          }
          // Generate a unique filename
          const filename = `gemini-image-${Date.now()}.jpg`
          const filePath = path.join(OUTPUT_DIR, filename)
          // Write the image file
          const buffer = Buffer.from(imageData, 'base64')
          fs.writeFileSync(filePath, buffer)
          //console.log(`Image saved to ${filePath}`)
          return filePath
        }
        // Log any text part
        if (part.text) {
          console.log('Generated text:', part.text)
        }
      }

      console.error('Error: No valid image data found in parts.')
      return null
    } catch (error: any) {
      console.error('Error generating image:', error)
      return null
    }
  }

  /**
   * Generates SEO-friendly metadata (title, description, keywords) for Adobe Stock.
   * @param enhancedPrompt AI prompt describing the image
   * @returns An object with title, description, and keywords or null on failure
   */
  generateStockMetadata = async (enhancedPrompt: string): Promise<AssetMetaData | null> => {
    try {
      // Build instruction prompt
      const instruction = `You are an expert stock photo metadata generator.
      Based on the following detailed prompt, produce a JSON object with the following keys:

      1) title: a concise, SEO-friendly title (maximum 70 characters),
      2) description: a factual, objective 2â€“3 sentence description of the image content. Do NOT mention usage rights, licensing, commercial use, or watermarks (maximum 200 characters).
      3) keywords: an array of up to 50 relevant, comma-separated keywords suitable for stock search. Avoid terms related to licensing such as "no watermark", "free to use", or "commercial use".

      Prompt:
      "${enhancedPrompt}"`
      // Call Gemini
      const response = await this.geminiAi.models.generateContent({
        model: ENV.AI_MODEL,
        contents: instruction,
      })

      const text = response?.candidates?.[0]?.content?.parts?.[0]?.text
      if (!text) return null

      // Extract JSON substring
      const start = text.indexOf('{')
      const end = text.lastIndexOf('}') + 1
      if (start === -1 || end === -1) return null
      const jsonStr = text.slice(start, end)

      const metadata = JSON.parse(jsonStr)
      const disallowedTerms = ['commercial use', 'no watermark', 'free to use', 'royalty free', 'license']
      const keywords: string[] = (metadata.keywords || []).filter((kw: string) => !disallowedTerms.some((term) => kw.toLowerCase().includes(term)))
      const description: string = metadata.description?.replace(new RegExp(disallowedTerms.join('|'), 'gi'), '').trim()

      return {
        title: metadata.title?.trim(),
        description,
        keywords,
      }
    } catch (error) {
      console.error('Error generating stock metadata:', error)
      return null
    }
  }
}
